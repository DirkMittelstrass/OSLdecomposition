---
title: "Report: signal component seperated dose evaluation"
date: 2019-05-22
output:
  html_document: 
    df_print: paged
    toc: true
    toc_depth: 3
  runtime: shiny
---
```{r global_stuff, include=FALSE}

# TODO

# - more information about component fitting results
# - add cross-correlation viewer
# - change from aliquot_selection to position_list
# - silent and prove calc_CentralDose
#

library(Luminescence)
library(numOSL)
library(OSLdecomposition)
library(knitr)

knitr::opts_chunk$set(fig.width=10, 
                      fig.asp=.6, 
                      warning=FALSE,
                      error=FALSE,
                      echo=FALSE)

# choose BIN file:
#path <- file.choose()
#path <- "W:\\data\\BK-8_1295-1280_63-40um_2mm_Qz1_ed.BIN"
#path <- "C:\\Users\\mitte\\Desktop\\Masterarbeit\\data\\Oy7-01-14_63-100_1mm_Qz1-1_ed.BIN"
#path <- "C:\\Users\\mitte\\Desktop\\Masterarbeit\\data\\BK-8_1295-1280_63-40um_2mm_Qz1_ed.BIN"
# path <- "C:\\Users\\mitte\\Desktop\\Masterarbeit\\data\\BT1214_all_FKQ_mx.BIN"
# path <- "C:\\Users\\mitte\\Desktop\\Masterarbeit\\data\\BT594_607_608_612_619.BIN"

```

### Start parameters

```{r start_parameters, echo = TRUE}


path <- "C:\\Users\\mitte\\Desktop\\Masterarbeit\\data\\Batagai_2-7_B-2-47_OSL_63-100_2mm_Qz1_ed.BIN"

# Data set dependend parameters
max_number_of_components <- 4
record_type <- "OSL"
drop_selection <-c(1:4) #c(25:48)  # c(22)  # which aliquots to leave out?

# values from Maggis Sibirian data sets
dose_rate <- 4.95 / 60 # Gy/s
age_rate <- 0.635 # ka/Gy

# Algorithm parameters
algorithm <- "nls"
negative_values_to_zero <- FALSE
scaling <- 0.01

```



##	Step 1: Get OSL decay parameter


```{r decay_parameter}

# read BIN file:
lum_data <- read_BIN2R(path, 
                       fastForward = TRUE,
                       txtProgressBar = FALSE)
lum_data[drop_selection] <- NULL

aliquot.n <- length(lum_data)

aliquot.positions<- NULL
# get measurement positions
for (i in 1:aliquot.n) {
  
  aliquot.positions <- c(aliquot.positions 
                         , lum_data[[i]]@records[[1]]@info[["POSITION"]])
}

# calc arithmetic mean curve
global_curve <- sum_OSLcurves(lum_data,
                            record_type = record_type,
                            output.plot = TRUE)

# Check if first time point is zero, if yes, correct it
if (global_curve$time[1] == 0) {
  global_curve$time <- global_curve$time + global_curve$time[2] - global_curve$time[1]
  writeLines("Time axis shifted one step to the left to prevent start-at-zero")
  # Note: decompose_OSLcurve does not use the time axis -> no need to correct single curves
}

# find components via fitting
global_components <- fit_OSLcurve(global_curve,
                                  algorithm = "numOSL",
                                  N.allowed = c(1:max_number_of_components),
                                  significance.threshold = 0.1,
                                  stimulation.intensity = 30)

# Add integration intervals to global parameter table
global_components <- calc_OSLintervals(global_components, global_curve)

# Add component amplitudes to global parameter table
if (algorithm == "det") {
  
  global_components <- decompose_OSLcurve(global_curve,
                                      global_components,
                                      offset.value = 0,
                                      negative.values.to.zero = negative_values_to_zero)
} else {

  global_components <- decompose_OSLalternatively(global_curve,
                                              global_components,
                                              algorithm = algorithm,
                                              offset.value = 0,
                                              negative.values.to.zero = negative_values_to_zero)
}


choices <- as.list(c("Late background", 
                     as.character(global_components$name)))

global_output <- data.frame(lambda = round(global_components$lambda, digits = 4),
                            lambda_error = round(global_components$lambda.error, digits = 4),
                            cross_section = paste0(format(global_components$cross.section, digits = 3, scientific = TRUE)," cmÂ²"),
                            estimated_component = global_components$name,
                            amplitude = round(global_components$n),
                            error = round(global_components$n.error))
kable(global_output, align = "l")

# Show decomposed global curve
plot_OSLcurve(global_curve, global_components, algorithm = algorithm)

```
      
###	Curve viewer

```{r curve_viewer, echo=FALSE}

# Determine indicies of OSL records in lum_data
record_index <- NULL
for (i in 1:length(lum_data[[1]]@records)) {
  
  if (lum_data[[1]]@records[[i]]@recordType == record_type) {
    
    record_index <- c(record_index, i)
  }
}

# Determine zoom minimum (10 data points)
zoom_min <- ceiling(10*100 / length(global_curve$time)) / 100

# Create shiny plot to surf through curves
#numericInput("aliquot_i", "Aliquot no.: ", value = 1, min = 1, max = aliquot.n)
#numericInput("record_i", "Record no.: ", value = 1, min = 1, max = length(record_index))

sliderInput("aliquot_i", "Aliquot no.: ", value = 1, step = 1, min = 1, max = aliquot.n)
sliderInput("record_i", "Curve no.: ", value = 1, step = 1, min = 1, max = length(record_index))

radioButtons("algorithm", "Decomposition by ...",
             c("Nonlinear regression" = "nls",
               "Determinants" = "det"))
checkboxInput("to_zero", "No values < 0?", value = FALSE)
sliderInput("zoom", "X axis zoom", min = zoom_min, max = 1, value = 1)


renderPlot(width = 900, height = 450,res = 100,
   {
     i <- record_index[input$record_i]
     record <- lum_data[[input$aliquot_i]]@records[[i]]
     plot_title <- paste0("Record ", i, " of aliquot ", input$aliquot_i,
                          " (pos.=", record@info[["POSITION"]], "): ",
                          record@info[["DTYPE"]], 
                          " (dose=", record@info[["IRR_TIME"]], ")")
     
    if (input$algorithm == "det") {

      decomposition <- decompose_OSLcurve(record@data,
                                          global_components,
                                          offset.value = 0,
                                          negative.values.to.zero = input$to_zero)
    } else {

      decomposition <- decompose_OSLalternatively(record@data,
                                                  global_components,
                                                  algorithm = input$algorithm,
                                                  offset.value = 0,
                                                  negative.values.to.zero = input$to_zero)
    }
            
    plot_OSLcurve(record, 
                  decomposition, 
                  display = "detailed", 
                  title = plot_title,
                  algorithm = algorithm,
                  zoom = input$zoom)
})

```


##	Step 2: Calculate equivalent dose component-wise

```{r SAR_decomposition, include=FALSE}

# the first data set shall be analyzed classically by Murray and Wintle (2000) approach
SAR.classic <- analyse_SAR.CWOSL(lum_data,
                                       signal.integral.min = 1,
                                       signal.integral.max = 5,
                                       background.integral.min = 80,
                                       background.integral.max = 100,
                                       fit.method = "EXP OR LIN",
                                      plot = FALSE)

# transform LxTx tables into list format
# Might be shorter if using merge():
# merge(x = results$data, y = results$LnLxTnTx.table, by = "UID")

LxTx <- SAR.classic@data$LnLxTnTx.table
SAR.classic@data$LnLxTnTx.table <- NULL
UID <- unique(LxTx$UID)
for (i in 1:length(UID)) {
  
  SAR.classic@data$LnLxTnTx.table[[i]] <- LxTx[LxTx$UID == UID[i], c(3,12:13,4:7)]
}


SAR.decomposed <- decompose_SARdata(lum_data,
                             components = global_components,
                             record_type = record_type,
                             algorithm = algorithm,
                             scaling = scaling)





if (length(SAR.classic@data[["data"]][["De"]]) != length(SAR.decomposed[[1]]@data[["data"]][["De"]])) {
  stop("Number of analyzed aliquots does not match between classic SAR protocol and decomposition SAR protocol. Script stopped")
}
aliquot.n <- length(SAR.classic@data[["data"]][["De"]])

SAR.list <- c(SAR.classic, SAR.decomposed)
component.number <- length(SAR.decomposed)



```

### Signal-dose curve viewer

```{r}

#kable(SAR.list[[2]]@data[["LnLxTnTx.table"]][[1]], digits = c(0,2,2,0,0,0,0,0,0))

# Create shiny plot to surf through curves
sliderInput("aliquot_i2", "Aliquot no.: ", value = 1, step = 1, min = 1, max = aliquot.n)
sliderInput("component_i", "Result table no.: ", value = 1, step = 1, min = 1, max = length(SAR.list))
sliderInput("gc_scale", "Error scaling Growth curve:", value = scaling, min = 0.001, max = 1)

renderPlot(width = 600, height = 600, res = 100,
   {
     plot_GrowthCurve2(SAR.list[[input$component_i]]@data[["LnLxTnTx.table"]][[input$aliquot_i2]],
                       fit.method = "EXP OR LIN",
                       scaling = scaling)

})

renderTable({
  
     SAR.list[[input$component_i]]@data[["LnLxTnTx.table"]][[input$aliquot_i2]]
     #kable(DF, digits = c(0,2,2,0,0,0,0,0,0))
})

```


## Step 3: Calculate paleodose and age

```{r result_preparation, include=FALSE}

# prepare data sets
results <- list(NULL)
results.passed <- list(NULL)
result <- data.frame(NULL)
overview <- data.frame(NULL)
recup.values <- NA[1:aliquot.n]
recyc.values <- NA[1:aliquot.n]

# wrap Central Age Model function
calc_CAM <- function(data) {
  
  dose <- try(calc_CentralDose(data.frame(De = data$De,
                                   De.Error = data$De.Error),plot = FALSE))
  
  if (attr(dose,"class") == "try-error") return("-")
  
  age <- round(dose@data[["summary"]][["de"]] * age_rate, digits = 2)
  age.error <- round(dose@data[["summary"]][["de_err"]] * age_rate, digits = 2)
 
  return(paste0(age, " +- ", age.error," ka"))
}

# cycle through results and construct result tables
for (k in 1:length(SAR.list)) {
  
  # the amplitude of the natural signal of this component has to be seperated from the LxTx table
  n.natural <- NULL

  # in the data achieved from analyze_CWOSLSAR, the rejection criteria are stored differently
  if (k == 1) {

    # ATTENTION: the rejection criteria may change its position
    RC <- SAR.list[[k]]@data[["rejection.criteria"]]
    recup.string <- NULL
    recyc.string <- NULL
    x <- 1
    
    while ((is.null(recup.string) || is.null(recyc.string)) 
           && (x < length(RC[["Criteria"]]))) {
      
      if (grepl("Recyc", RC[["Criteria"]][x])) {
        recyc.string <- RC[["Criteria"]][x]
        writeLines(paste0("[SAR.classic] Rejection criterion '", 
                          recyc.string,"' set as recycling ratio"))
      }
      
      if (grepl("Recup", RC[["Criteria"]][x])) {
      recup.string <- RC[["Criteria"]][x]
      writeLines(paste0("[SAR.classic] Rejection criterion '", 
                        recyc.string,"' set as recycling ratio"))
      }
      x <- x + 1
      
    }
    
    recup.values <- round(RC[["Value"]][RC[["Criteria"]] == recup.string], digits = 3)
    recyc.values <- round(RC[["Value"]][RC[["Criteria"]] == recyc.string], digits = 3)
    
    # short version: RC$Criteria[grep("Recyc", RC[["Criteria"]])]
    
  } else {
    
    recup.values <- round(SAR.list[[k]]@data[["data"]][["recuperation.rate"]], digits = 3)
    recyc.values <- round(SAR.list[[k]]@data[["data"]][["recycling.ratio"]], digits = 3)
  }
  
    # from decompose.SARdata we need just to extract n.natural differently
    for (i in 1:length(SAR.list[[k]]@data[["LnLxTnTx.table"]])) {
        n.natural <- c(n.natural, 
                       SAR.list[[k]]@data[["LnLxTnTx.table"]][[i]][["LnLx"]][1])
    }
  
  # build De result table for this component
  De.data <- SAR.list[[k]]@data[["data"]]
  result <- data.frame(n.natural = round(n.natural),
                       De = round(De.data[["De"]] * dose_rate, digits = 2),
                       De.Error = round(De.data[["De.Error"]] * dose_rate, digits = 2),
                       D01 = round(De.data[["D01"]] * dose_rate),
                       Fit = De.data[["Fit"]],
                       recup = recup.values,
                       recyc = recyc.values,
                       RC.status = De.data[["RC.Status"]])
  
  results[[k]] <- result
  
  result.passed <- data.frame(De = result[result$RC.status == "OK",]$De,
                                   De.Error = result[result$RC.status == "OK",]$De.Error)
  results.passed[[k]] <- result.passed
  
  # Build overview table
  overview <- rbind(overview,
                    data.frame(comp.name = choices[[k]],
                               De.median = median(result$De, na.rm = TRUE),
                               age.CAM = calc_CAM(result),
                               n.nat.median = median(result$n.natural, na.rm = TRUE),
                               recup.median = median(recup.values, na.rm = TRUE),
                               recyc.median = median(recyc.values, na.rm = TRUE),
                               RC.passed = length(result.passed$De),
                               De.passed = median(result.passed$De, na.rm = TRUE),
                               age.passed = calc_CAM(result.passed)))
}

```

### Overview

```{r overview_table, message=FALSE, paged.print=TRUE}

kable(overview, digits = c(0,1,0,0,4,4,0,1,0))

```

### De-tables for each component

```{r De_tables, paged.print=TRUE}
for (k in 1:length(results)) {
  #De_table <- cbind(data.frame(position = aliquot.positions), results[[k]])
  writeLines(paste0("--------- ", choices[[k]], "---------"))
  print(results[[k]])
  #kable(De_table)
}
```

### KDE plots for each component

```{r KDE_plots}

for (k in 1:length(results)) {
  
  writeLines(" ")
  writeLines("------------------------------------------------")
  writeLines(paste0(" Results of ", choices[[k]]))
  writeLines("------------------------------------------------")
  writeLines(" ")
    
  header_text <- paste0(choices[[k]], " KDE plot")
    try(plot_KDE(data.frame(De = results[[k]]$De, 
                            De.Error = results[[k]]$De.Error),
                 main = header_text))
  
  header_text <- paste0(choices[[k]], " KDE plot (RC passed)")
    try(plot_KDE(data.frame(De = results.passed[[k]]$De, 
                            De.Error = results.passed[[k]]$De.Error),
                 main = header_text))
  
}

```

## Cross correlation viewer


```{r cross_correlations}

choices2 <- as.list(colnames(results[[1]]))

selectInput("X_i", "Component X-axis: ", choices)
selectInput("X", "Data X-axis", choices2)

selectInput("Y_i", "Component Y-axis: ", choices)
selectInput("Y", "Data Y-axis", choices2)

renderPlot(width = 800, height = 450,res = 100,
    {
     X <- results[[which(choices == input$X_i)]][[input$X]]
     X.title <- paste0(input$X, " of ", input$X_i)
     
     Y <- results[[which(choices == input$Y_i)]][[input$Y]]
     Y.title <- paste0(input$Y, " of ", input$Y_i)
     
     if (X == Y) {
       hist(X, xlab = X.title)
     } else {
       plot(X, Y,
            xlab = X.title, ylab = Y.title)
     }
   })
```

