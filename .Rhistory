components <- data.frame(name = c("fast", "medium", "slow"),
lambda = c(2, 0.5, 0.02),
n = c(1000, 1000, 10000))
# Simulate a CW-OSL curve including some signal noise
curve <- simulate_OSLcomponents(components, simulate.curve = TRUE, add.poisson.noise = TRUE)
components <- decompose_OSLcurve(curve, components)
# Display the simulated curve
plot_OSLcurve(curve, components)
library(Luminescence)
BT594 <- RLum.OSL_decomposition(BT594, K = 3, report = TRUE)
# the following three lines load necessary functions which will be integrated in Luminescence in the future
.LuminescenceEnv <- new.env(parent = emptyenv())
source(system.file("beta", "analyse_SAR.CWOSL_beta.R", package = "OSLdecomposition"))
source(system.file("beta", "calc_OSLLxTxDecomposed.R", package = "OSLdecomposition"))
library(Luminescence)
library(OSLdecomposition)
# BIN files measured with Risoe TL/OSL Reader or Freiberg Instruments lexsygs can be used as usual.
# Here, we use the example data set provided by the Luminescence package
data(ExampleData.BINfileData, envir = environment())
OSLdata <- Risoe.BINfileData2RLum.Analysis(CWOSL.SAR.Data)
# Own data sets can be easily selected for example by the following code snippet:
#
# OSLdata <- read_BIN2R(file.choose(), fastForward = TRUE)
# Consistent detection settings are essential. These are checked by RLum.OSL_correction() which also
# provides various tools for data correction and data improvement, like background subtraction.
# But all these tools are optional. Most data sets can be adequately decomposed without running RLum.OSL_correction()
OSLdata_corrected <- RLum.OSL_correction(OSLdata)
# In the first step, the OSL components and their decay rates are identified
# by multi-exponential fitting at a global CW-OSL curve.
# The obtained information can be found at: OSLdata_fitted$OSL_COMPONENTS
OSLdata_fitted <- RLum.OSL_global_fitting(OSLdata_corrected,
stimulation_intensity = 75)
# In the second step, a very robust algorithm uses the decay constants to decompose
# every CW-OSL record into its signal components, see OSLdata_decomposed[[...]]@records[[...]]@info[["COMPONENTS"]]
OSLdata_decomposed <- RLum.OSL_decomposition(OSLdata_fitted, K = 3)
# The De's for specific signal components can be calculated without the need of
# defining integration intervals
De_fast_component <- analyse_SAR.CWOSL_beta(OSLdata_decomposed, OSL.component = 1)
De_medium_component <- analyse_SAR.CWOSL_beta(OSLdata_decomposed, OSL.component = 2)
# We can compare the component-based De's with the classical calculated late background subtraction De's
De_late_background <- analyse_SAR.CWOSL_beta(OSLdata, 1, 14, 800, 1000, plot = FALSE)
plot_KDE(list(De_late_background,   # black
De_fast_component,    # red
De_medium_component)) # green
plot_RadialPlot(list(De_late_background,    # black
De_fast_component,     # red
De_medium_component))  # green
?OSLdecomposition
save.image("C:/Users/mitte/Desktop/TestSpaceEnv.RData")
load("C:/Users/mitte/Desktop/TestSpaceEnv.RData")
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/RLum.OSL_decomposition.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/RLum.OSL_global_fitting.R', encoding = 'UTF-8')
View(result)
?percent
??percent
label_percent(0.01234)
scales::label_percent(0.01234)
scales::percent(0.01234)
scales::percent(0.01234, accuracy = 0.1)
scales::percent(0.01234, accuracy = 0.2)
scales::percent(0.01234, accuracy = 0.01)
scales::percent(0.01234, accuracy = 0.1, suffix = " %")
scales::percent(c(0.01234, 0.2), accuracy = 0.1, suffix = " %")
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
initial_table <- data.frame(NULL)
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Also build a data.frame with the initial signals
new_col <- data.frame(row = scales::percent(result[,colnames(result) == paste0("initial.signal.", k)]),
accuracy = 0.1, suffix = " %")
colnames(new_col) <- input_table$name[k]
initial_table <- cbind(initial_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
intensity_tables[[j]] <- cbind(aliquot_table, initial_table)
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
initial_table <- data.frame(NULL)
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Also build a data.frame with the initial signals
new_col <- data.frame(row = scales::percent(result[,colnames(result) == paste0("initial.signal.", k)]),
accuracy = 0.1, suffix = " %")
colnames(new_col) <- input_table$name[k]
initial_table <- data.frame(initial_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
intensity_tables[[j]] <- cbind(aliquot_table, initial_table)
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
initial_table <- NULL
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Also build a data.frame with the initial signals
new_col <- data.frame(row = scales::percent(result[,colnames(result) == paste0("initial.signal.", k)]),
accuracy = 0.1, suffix = " %")
colnames(new_col) <- input_table$name[k]
initial_table <- data.frame(initial_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
intensity_tables[[j]] <- cbind(aliquot_table, initial_table)
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
# Also append column with initial signal percentage
for (k in 1:K) {
new_col <- data.frame(row = scales::percent(result[,colnames(result) == paste0("initial.signal.", k)]),
accuracy = 0.1, suffix = " %")
colnames(new_col) <- input_table$name[k]
aliquot_table <- cbind(aliquot_table, new_col)
}
intensity_tables[[j]] <- aliquot_table
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
View(aliquot_table)
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
# Also append column with initial signal percentage
for (k in 1:K) {
initial_signals <- result[,colnames(result) == paste0("initial.signal.", k)]
new_col <- data.frame(row = scales::percent(initial_signals, accuracy = 0.1, suffix = " %"))
colnames(new_col) <- input_table$name[k]
aliquot_table <- cbind(aliquot_table, new_col)
}
intensity_tables[[j]] <- aliquot_table
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
# Also append column with initial signal percentage
for (k in 1:K) {
initial_signals <- result[,colnames(result) == paste0("initial.signal.", k)]
new_col <- data.frame(row = scales::percent(initial_signals, suffix = " %")) # accuracy = 0.1,
colnames(new_col) <- input_table$name[k]
aliquot_table <- cbind(aliquot_table, new_col)
}
intensity_tables[[j]] <- aliquot_table
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
### This chunk rearranges the data for the dynamic tabs, no direct output is produced
intensity_tables <- list()
barplots <- list()
barplot_labels <- list()
for (j in 1:length(record)) {
result <- dec_data$results[dec_data$results$list.index == record[[j]]$sequence,]
if(result$IRR_TIME[1] == 0) result$IRR_TIME[1] <- "?"
aliquot_table <- subset(result, select = c(record.index, IRR_TIME))
plot_table <- data.frame(NULL)
colnames(aliquot_table) <- c("data index", "irradiation time (s)")
### Define Lx and Tx data points
result <- data.frame(result, type = factor("?", levels = c("?", "Lx", "Tx")))
# Where is the highest regenerated dose?
max_Lx <- which.max(result$IRR_TIME[2:length(result$IRR_TIME)]) + 1
# get a index sequence: i = 3, 5, 7, 9
i_Lx <- 1:((max_Lx - 1)/2) * 2 + 1
result$type[i_Lx] <- "Lx"
i_Tx <- 1:(nrow(result)/2) * 2
result$type[i_Tx] <- "Tx"
for (k in 1:K) {
intensities <- result[,colnames(result) == paste0("n.", k)]
#intensities_reduced <- intensities - result[,colnames(result) == paste0("n.residual.", k)]
sigmas <- result[,colnames(result) == paste0("n.error.", k)]
# Append current component to Table 1 table
new_col <- data.frame(row = paste0(round(intensities), " ± ", round(sigmas)))
colnames(new_col) <- paste0("$n_", k, " ± \\sigma_", k, "$ (", input_table$name[k] ,")")
aliquot_table <- cbind(aliquot_table, new_col)
# Include component only in the bar-plot if it is bleached to at least 50 %
bleaching_grade <- 1 - sum(result[,colnames(result) == paste0("n.residual.", k)], na.rm = TRUE) /
sum(intensities, na.rm = TRUE)
if (bleaching_grade >= 0.95) {
# Append current component to Figure 2 plot data
plot_table <- rbind(plot_table,
data.frame(x_axis = 1:length(intensities),
y_axis = intensities,
y_lower = intensities - sigmas,
y_upper = intensities + sigmas,
component = factor(input_table$name[k],
levels = input_table$name),
type = result$type))
}
}
# Also append column with initial signal percentage
for (k in 1:K) {
initial_signals <- result[,colnames(result) == paste0("initial.signal.", k)]
new_col <- data.frame(row = scales::percent(initial_signals, accuracy = 0.1, suffix = " %"))
colnames(new_col) <- input_table$name[k]
aliquot_table <- cbind(aliquot_table, new_col)
}
intensity_tables[[j]] <- aliquot_table
barplots[[j]] <- plot_table
barplot_labels[[j]] <- data.frame(breaks = 1:length(intensities),
labels = paste0("#", 1:length(intensities),
"\n", result$IRR_TIME, " s"))
# add record@info[["IRR_UNIT"]]
}
BT594 <- RLum.OSL_decomposition(BT594, K = 3, report = TRUE)
library(Luminescence)
library(OSLdecomposition)
BT594 <- RLum.OSL_decomposition(BT594, K = 3, report = TRUE)
BT594 <- RLum.OSL_decomposition(BT594, K = 3, report = TRUE)
save.image("C:/Users/mitte/Desktop/TestSpaceEnv.RData")
load("C:/Users/mitte/Desktop/TestSpaceEnv.RData")
View(data_set)
View(BT594)
A <- BT594[[2]]@records[[1]]
A$COMPONENTS
A@info$COMPONENTS
A@info
colnames(A@info)
names(A@info)
"COMPONENTS" %in% names(A@info)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/plot_OSLcurve.R', encoding = 'UTF-8')
library(OSLdecomposition)
plot_OSLcurve(BT594[[1]]record[[1]])
BT594[[1]]record[[1]]
plot_OSLcurve(BT594[[1]]@record[[1]])
plot_OSLcurve(BT594[[1]]@records[[1]])
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/plot_OSLcurve.R', encoding = 'UTF-8')
plot_OSLcurve(BT594[[1]]@records[[1]])
plot_OSLcurve(BT594[[1]]@records[[2]])
plot_OSLcurve(BT594[[1]]@records[[3]])
class(BT594[[1]]@records[[3]])
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/plot_OSLcurve.R', encoding = 'UTF-8')
citation("kableExtra")
?decompose_OSLcurve
getwd()
View(BT594)
?install.packages()
?tempfile
tempdir()
# Script example
# Load libraries
library(OSLdecomposition)
library(Luminescence)
# Read BIN file
data <- read_BIN2R(file.choose(), fastForward = TRUE)
# Check the data for consistency and apply some corrections (optional)
data <- RLum.OSL_correction(data)
# Identify the OSL components occuring in your data set
data <- RLum.OSL_global_fitting(data)
# Separate components in each measurement
data <- RLum.OSL_decomposition(data)
# The dose calculation is handled by the Luminescence package
# But as OSLdecomposition data sets are not support yet, we need a workaround:
.LuminescenceEnv <- new.env(parent = emptyenv())
source(system.file("beta", "analyse_SAR.CWOSL_beta.R", package = "OSLdecomposition"))
source(system.file("beta", "calc_OSLLxTxDecomposed.R", package = "OSLdecomposition"))
# Calculate Fast component De values
results_fast <- analyse_SAR.CWOSL_beta(data, OSL.component = 1)
# Calculate Medium component De values
results_medium <- analyse_SAR.CWOSL_beta(data, OSL.component = 2)
# Compare the results in an Abanico plot
plot_AbanicoPlot(list(results_fast, results_medium))
save.image("C:/Users/mitte/Desktop/TestSpaceEnv.RData")
