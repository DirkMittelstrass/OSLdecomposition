axis.text = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
Dlot.2 <- rbind(data.frame(F.value = R.table[selection_2,]$F,
F.line = factor("same_line_weighted")),
data.frame(F.value = R.table[selection_2 & !is.na(R.table$F.next),]$F.next,
F.line = factor("next_line_weighted")))
Dlot.2$F.value <- log10(Dlot.2$F.value)
Plot.2 <- ggplot(Dlot.2, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(x = "F-value") +
ggtitle("DE+LM") +
theme(legend.position = "none",
axis.title = element_text(size=16), axis.title.y = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank(),
axis.text.x = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
lay <- rbind(c(rep(1,10),rep(2,9)))
grid.arrange(Plot.1, Plot.2, layout_matrix = lay)
# How many values were used?
print(paste0("F with DE only: ", nrow(R.table[selection_1,])))
print(paste0("F.next with DE only: ", nrow(R.table[selection_1,]) & !is.na(R.table$F.next),])))
library(ggplot2)
library(gridExtra)
theme_set(theme_bw())
pre_selection_1 <- R.table$Channel.width * R.table$Channels
selection_1 <- (R.table$Algorithm == 3) & (pre_selection_1 >= 40)
pre_selection_2 <- R.table$Channel.width * R.table$Channels
selection_2 <- (R.table$Algorithm == 3) & (pre_selection_2 <= 20)
Dlot.1 <- rbind(data.frame(F.value = R.table[selection_1,]$F,
F.line = factor("same_line")),
data.frame(F.value = R.table[selection_1 & !is.na(R.table$F.next),]$F.next,
F.line = factor("next_line")))
Dlot.1$F.value <- log10(Dlot.1$F.value)
Plot.1 <- ggplot(Dlot.1, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(y = "Event Density per Order of 10", x = "F-value") +
ggtitle("DE") +
theme(legend.position = "none",
axis.title = element_text(size=16),
axis.text = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
Dlot.2 <- rbind(data.frame(F.value = R.table[selection_2,]$F,
F.line = factor("same_line_weighted")),
data.frame(F.value = R.table[selection_2 & !is.na(R.table$F.next),]$F.next,
F.line = factor("next_line_weighted")))
Dlot.2$F.value <- log10(Dlot.2$F.value)
Plot.2 <- ggplot(Dlot.2, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(x = "F-value") +
ggtitle("DE+LM") +
theme(legend.position = "none",
axis.title = element_text(size=16), axis.title.y = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank(),
axis.text.x = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
lay <- rbind(c(rep(1,10),rep(2,9)))
grid.arrange(Plot.1, Plot.2, layout_matrix = lay)
# How many values were used?
print(paste0("F with DE only: ", nrow(R.table[selection_1,])))
print(paste0("F.next with DE only: ", nrow(R.table[selection_1,] & !is.na(R.table$F.next),])))
library(ggplot2)
library(gridExtra)
theme_set(theme_bw())
pre_selection_1 <- R.table$Channel.width * R.table$Channels
selection_1 <- (R.table$Algorithm == 3) & (pre_selection_1 >= 40)
pre_selection_2 <- R.table$Channel.width * R.table$Channels
selection_2 <- (R.table$Algorithm == 3) & (pre_selection_2 <= 20)
Dlot.1 <- rbind(data.frame(F.value = R.table[selection_1,]$F,
F.line = factor("same_line")),
data.frame(F.value = R.table[selection_1 & !is.na(R.table$F.next),]$F.next,
F.line = factor("next_line")))
Dlot.1$F.value <- log10(Dlot.1$F.value)
Plot.1 <- ggplot(Dlot.1, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(y = "Event Density per Order of 10", x = "F-value") +
ggtitle("DE") +
theme(legend.position = "none",
axis.title = element_text(size=16),
axis.text = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
Dlot.2 <- rbind(data.frame(F.value = R.table[selection_2,]$F,
F.line = factor("same_line_weighted")),
data.frame(F.value = R.table[selection_2 & !is.na(R.table$F.next),]$F.next,
F.line = factor("next_line_weighted")))
Dlot.2$F.value <- log10(Dlot.2$F.value)
Plot.2 <- ggplot(Dlot.2, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(x = "F-value") +
ggtitle("DE+LM") +
theme(legend.position = "none",
axis.title = element_text(size=16), axis.title.y = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank(),
axis.text.x = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
lay <- rbind(c(rep(1,10),rep(2,9)))
grid.arrange(Plot.1, Plot.2, layout_matrix = lay)
# How many values were used?
print(paste0("F with DE only: ", nrow(R.table[selection_1,])))
print(paste0("F.next with DE only: ", nrow(R.table[selection_1 & !is.na(R.table$F.next),])))
print(paste0("F with LM: ", nrow(R.table[selection_2,])))
print(paste0("F.next  with LM: ", nrow(R.table[selection_2 & !is.na(R.table$F.next),])))
library(ggplot2)
library(gridExtra)
theme_set(theme_bw())
pre_selection_1 <- R.table$Channel.width * R.table$Channels
selection_1 <- (R.table$Algorithm == 3) & (pre_selection_1 >= 40)
pre_selection_2 <- R.table$Channel.width * R.table$Channels
selection_2 <- (R.table$Algorithm == 3) & (pre_selection_2 <= 20)
Dlot.1 <- rbind(data.frame(F.value = R.table[selection_1,]$F,
F.line = factor("same_line")),
data.frame(F.value = R.table[selection_1,]$F.next,
F.line = factor("next_line")))
Dlot.1$F.value <- log10(Dlot.1$F.value)
Plot.1 <- ggplot(Dlot.1, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(y = "Event Density per Order of 10", x = "F-value") +
ggtitle("DE") +
theme(legend.position = "none",
axis.title = element_text(size=16),
axis.text = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
Dlot.2 <- rbind(data.frame(F.value = R.table[selection_2,]$F,
F.line = factor("same_line_weighted")),
data.frame(F.value = R.table[selection_2,]$F.next,
F.line = factor("next_line_weighted")))
Dlot.2$F.value <- log10(Dlot.2$F.value)
Plot.2 <- ggplot(Dlot.2, aes(x = F.value, color = F.line)) +
geom_density(size=1) + ylim(0, 0.7) +
scale_x_continuous(limits = c(-2,7), breaks = c(-1,0,1,2,3,4,5,6),
labels = c("0.1","1", "10","100","10^3","10^4","10^5","10^6")) +
labs(x = "F-value") +
ggtitle("DE+LM") +
theme(legend.position = "none",
axis.title = element_text(size=16), axis.title.y = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank(),
axis.text.x = element_text(size=14),
plot.title = element_text(size=18, face="bold"))
###################################################
lay <- rbind(c(rep(1,10),rep(2,9)))
grid.arrange(Plot.1, Plot.2, layout_matrix = lay)
# How many values were used?
print(paste0("F with DE only: ", nrow(R.table[selection_1,])))
print(paste0("F.next with DE only: ", nrow(R.table[selection_1 & !is.na(R.table$F.next),])))
print(paste0("F with LM: ", nrow(R.table[selection_2,])))
print(paste0("F.next  with LM: ", nrow(R.table[selection_2 & !is.na(R.table$F.next),])))
# Calc photon energy: E = h*v  [W*s^2 * s^-1 = W*s = J]
E <-6.62606957e-34 * 299792458 * 10^9 / stimulation.wavelength
# Calc photon flux of stimulation light: Flux = I / E  [W/cm^2 / W*s = 1/s*cm^2]
Flux <- stimulation.intensity / (E * 1000)
Flux <- 30 / (6.62606957e-34 * (299792458 * 10^9 / 480) * 1000)
Flux * 2.6e-17
Flux <- 31 / (6.62606957e-34 * (299792458 * 10^9 / 480) * 1000)
Flux * 2.6e-17
Flux <- 30 / (6.62606957e-34 * (299792458 * 10^9 / 480) * 1000)
Flux * 4.28e-18
Flux * 1.09e-18
Flux * 3.04e-19
# ToDo, use more accurate lambda values
#lambda <- c(Fast = 2, Medium = 0.5, Slow1 = 0.1, Slow2 = 0.02)
# Calculated from Durcan & Duller, assuming an stimulation intensity of 30 mW/cm² (typical for a Risö OSL/TL DA-15)
lambda <- c(Fast = 1.9, Medium = 0.3, Slow1 = 0.08, Slow2 = 0.02)
X <- 1:length(lambda)
#algorithm_names <- c("numOSL","DE","DE+LM")
algorithm_names <- c("DE","DE+LM")
V.list <- list(n.Fast = c(0, 1000, 3000, 10000, 30000),
n.Medium = c(0, 1000, 3000, 10000),
n.Slow1 = c(0, 3000, 10000, 30000),
n.Slow2 = c(10000, 30000, 100000),
Background = c(0),
Channels = c(100, 200, 400),
Channel.width = c(0.1, 0.2, 0.5),
Additions = c(100, 400),
Algorithm = c(0, 1))
# from earlier simulations, we showed that the impact of uncorrected background signals,
# as well as from the number of additions is insignificant
# it was also shown, that unweighted fitting (Chi² = RSS) leads to more precise
# fast and medium component decay rates
V.max <- NULL
for (i in 1:length(V.list)) {
V.max <- c(V.max, length(V.list[[i]]))
}
N <- prod(V.max)
cat("Number of scenarios:", N,"\n")
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
?nls.control()
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
56/3
55/3
54/3
18*3
19*3
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
A <- try(1/0)
A <- try(sqrt(-1))
A
class(A)
A <- try(sqrt(c(-1, NA, 2)))
A <- try(ksf)
A
A[1]
A[2]
A
list(NULL)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
A <- list(NULL)
A <- list()
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
load("C:/Users/mitte/Desktop/R/OSLdecomposition/DevSpace.RData")
fit_OSLcurve(C)
D <- matrix(0, 10, 1, 5, 2, 3, ncol=2)
D <- matrix(c(0, 10, 1, 5, 2, 3), ncol=2)
D
D <- matrix(c(0, 1, 2, 10, 5, 3), ncol=2)
D
fit_OSLcurve(D)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(D)
D <- matrix(c(0, 1, 2, 4, 5, 42, 21, 10, 5, 3), ncol=2)
fit_OSLcurve(D)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(D)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(D)
D <- matrix(c(0, 1, 2, 3, 4, 42, 21, 10, 5, 3), ncol=2)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(D)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(D)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(D)
plot(D)
D <- matrix(c(0, 1, 2, 3, 4, 5, 42, 21, 10, 6, 4, 3), ncol=2)
fit_OSLcurve(D)
D <- matrix(c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 42, 21, 10, 6, 4, 3), ncol=2)
fit_OSLcurve(D)
D <- matrix(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 42, 21, 10, 6, 4, 3, 2.4), ncol=2)
fit_OSLcurve(D)
fit_OSLcurve(C, K.max = 2)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(C, K.max = 2)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(C, K.max = 2)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(C, K.max = 2)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(C, K.max = 2)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
fit_OSLcurve(C, K.max = 2)
fit_OSLcurve(D, K.max = 2)
fit_OSLcurve(D, K.max = 4, F.threshold = 1)
D <- matrix(c(0, 1, 2, 10, 5, 3), ncol=2)
fit_OSLcurve(D, K.max = 2, F.threshold = 1)
D <- matrix(c(0, 1, 2, 3, 4, 42, 21, 10, 5, 3), ncol=2)
fit_OSLcurve(D, K.max = 3, F.threshold = 1)
E <- fit_OSLcurve(D, K.max = 3, F.threshold = 1)
View(E)
E <- fit_OSLcurve(D, K.max = 3, F.threshold = 1, output.complex = TRUE)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
E <- fit_OSLcurve(D, K.max = 3, F.threshold = 1, output.complex = TRUE)
View(E)
D <- matrix(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 42, 21, 11, 7, 5, 4, 3), ncol=2)
D <- matrix(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 42, 21, 11, 7, 5, 4, 3), ncol=2)
D2 <- cbind(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7), (42, 21, 11, 7, 5, 4, 3))
D2 <- cbind(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7), c(42, 21, 11, 7, 5, 4, 3))
View(D2)
curve <- cbind(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7), c(42, 21, 11, 7, 5, 4, 3))
components <- fit_OSLcurve(curve, F.threshold = 3)
plot_OSLcurve(curve, components)
# Create arbitary decay curve
curve <- cbind(c(1, 2, 3, 4, 5, 6, 7, 8, 9),
c(42, 21, 11, 7, 5, 4, 3.1, 2.4, 2))
# Perform fitting
components <- fit_OSLcurve(curve, F.threshold = 3)
# Display results
plot_OSLcurve(curve, components)
### Example 1: Fitting of some arbitary decay curve ###
# Create curve with two components
curve <- cbind(c(1, 2, 3, 4, 5, 6, 7, 8, 9),
c(42, 20, 12, 7, 5, 4, 3.1, 2.4, 2))
# Perform fitting
components <- fit_OSLcurve(curve, F.threshold = 3)
# Display results
plot_OSLcurve(curve, components, display = "lin-log")
OSLdata <- Luminescence::Risoe.BINfileData2RLum.Analysis(Luminescence::CWOSL.SAR.Data)
OSLdata <- Luminescence::Risoe.BINfileData2RLum.Analysis(CWOSL.SAR.Data)
data(Luminescence::ExampleData.BINfileData, envir = environment())
OSLdata <- Luminescence::Risoe.BINfileData2RLum.Analysis(CWOSL.SAR.Data)
data(Luminescence::ExampleData.BINfileData, envir = environment())
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
# TODO
# -
library(Luminescence)
library(numOSL)
library(OSLdecomposition)
library(knitr)
knitr::opts_chunk$set(fig.width=10, fig.asp=.6, warning=FALSE, error=FALSE, echo=FALSE)
# alternative simulations:
V.list <- list(n.Fast = c(0, 1000, 3000, 10000, 30000),
n.Medium = c(0, 1000, 3000),
n.Slow1 = c(0, 3000, 10000),
n.Slow2 = c(10000, 30000, 100000),
Background = c(0),
Channels = c(100, 200, 400),
Channel.width = c(0.1, 0.2, 0.5),
Additions = c(500),
Algorithm = c(1,2,3))
V.list <- list(n.Fast = c(0, 1000, 3000, 10000, 30000),
n.Medium = c(0, 1000, 3000, 10000),
n.Slow1 = c(0, 3000, 10000, 30000),
n.Slow2 = c(10000, 30000, 100000),
Background = c(0),
Channels = c(100, 200, 400),
Channel.width = c(0.1, 0.2, 0.5),
Additions = c(100, 400),
Algorithm = c(0, 1))
# ToDo, use more accurate lambda values
#lambda <- c(Fast = 2, Medium = 0.5, Slow1 = 0.1, Slow2 = 0.02)
# Calculated from Durcan & Duller, assuming an stimulation intensity of 30 mW/cm² (typical for a Risö OSL/TL DA-15)
lambda <- c(Fast = 1.9, Medium = 0.3, Slow1 = 0.08, Slow2 = 0.02)
X <- 1:length(lambda)
#algorithm_names <- c("DE","DE+LM")
V.list <- list(n.Fast = c(0, 1000, 3000, 10000),
n.Medium = c(0, 1000, 3000, 10000),
n.Slow1 = c(0, 3000, 10000, 30000),
n.Slow2 = c(10000, 30000, 100000),
Background = c(0, 30),
Channels = c(100, 200, 400),
Channel.width = c(0.1, 0.2, 0.5),
Additions = c(100, 400))
# from earlier simulations, we showed that the impact of uncorrected background signals,
# as well as from the number of additions is insignificant
# it was also shown, that unweighted fitting (Chi² = RSS) leads to more precise
# fast and medium component decay rates
V.max <- NULL
for (i in 1:length(V.list)) {
V.max <- c(V.max, length(V.list[[i]]))
}
N <- prod(V.max)
cat("Number of scenarios:", N,"\n")
cat("Estimated time:", N * 0.33 / 60,"h\n")
V.i <- rep(1, length(V.list))
V.table <- data.frame(NULL)
for (j in 1:N) {
V <- NULL
for (i in 1:length(V.list)) {
if(V.i[i] > V.max[i]) {
V.i[i] <- 1
V.i[i + 1] <- V.i[i + 1] + 1
}
V <- c(V, V.list[[i]][V.i[i]])
}
V.i[1] <- V.i[1] + 1
V.table <- rbind(V.table, V) #, stringsAsFactors = FALSE)
}
colnames(V.table) <- names(V.list)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
library(OSLdecomposition)
if (c(TRUE, FALSE)) cat("Test")
A <- list(data.frame(a = "A"), c(1,2,3))
attr(A, "class")
attr(A, class)
attr(A, "class")
attr(A[[1]], "class")
is(A)
is(A)[1]
is(A[[1]])[1]
B <- stop("f")
B
B <- try(stop("f"))
is(B[[1]])[1]
is(B)[1]
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
library(OSLdecomposition)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/examples/example_CW.OSL.Data.R')
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/RLum.OSL_global_fitting.R')
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/RLum.OSL_global_fitting.R')
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
ibrary(Luminescence)
library(OSLdecomposition)
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
library(Luminescence)
library(OSLdecomposition)
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/RLum.OSL_global_fitting.R')
source('C:/Users/mitte/Desktop/R/OSLdecomposition/R/fit_OSLcurve.R', encoding = 'UTF-8')
library(Luminescence)
library(OSLdecomposition)
report <- TRUE # To save a lot of computing time, disable auto-reporting
# FB_10Gy is a dose recovery test with the La Fontainebleau quartz in the Bayreuth lexsyg system with green stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
FB <- read_BIN2R(data_path, fastForward = TRUE)
# Adequate background correction is recommended to prevent slow component overestimation.
# Here, the OSL measurements of an empty aliquot (data set entry 11) is subtracted from the other OSL
# measurements
FB_corrected <- RLum.OSL_correction(FB, background = 11)
FB_fitted <- RLum.OSL_global_fitting(FB_corrected,
stimulation_intensity = 50,
stimulation_wavelength = 530,
report = report)
View(FB_fitted)
FB_fitted[["OSL_COMPONENTS"]][["curve"]][["signal"]]
FB_fitted[[1]]@records[[1]]@data
save.image("C:/Users/mitte/Desktop/R/OSLdecomposition/TestSpace.RData")
