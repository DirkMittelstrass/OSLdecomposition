---
title: "Improve decomposition performance"
output:
  html_document:
    theme: readable
    df_print: paged
---


```{r setup, include=FALSE}

library(OSLdecomposition)
library(knitr)
library(ggplot2)
library(microbenchmark)
plot_theme <- theme_classic()


knitr::opts_chunk$set(fig.width=8,
                      fig.asp=.6,
                      results = "asis",
                      warning=FALSE,
                      message=FALSE,
                      error=FALSE,
                      echo=FALSE,
                      cache=FALSE)

```


To get through the CRAN checks and to improve the overall performance,
the `fit_OSLcurve` function needs to become faster. The most reasonable way to do 
this is to improve the test criterion calculation for the genetic evolution algorithm.
As test criterion, the [Residual sum of squares](https://en.wikipedia.org/wiki/Residual_sum_of_squares) 
(RSS) is used and calculated the following way:

```{r default_function}
# Subfunction for DE minimization
calc_RSS <- function(lambda_vector, RSScurve = curve){

  # The linear part of HELA (see Bluszcz & Adamiec 2006) is performed by my function decompose_OSLcurve()
  RSScomponents <- decompose_OSLcurve(RSScurve,
                                      lambda_vector,
                                      algorithm = "det",
                                      error.estimation = "none",
                                      verbose = FALSE)

  # Now add the residual curve to the input curve ...
  RSScurve <- simulate_OSLcomponents(RSScomponents,
                                     curve = RSScurve,
                                     simulate.curve = FALSE)

  # ... and calculate the residual sum of squares (RSS)
  RSS <- sum(RSScurve$residual^2)
  if (is.na(RSS) || (RSS <= 0)) RSS <- Inf
  return(RSS)
}
```

A preliminary test showed that `simulate_OSLcomponents` function needs more computing
time than the `decompose_OSLcurve`. A closer look and some quick research revealed
that not the *calculation* is the bottle neck but the many memory allocation due to
creating new data.frame and vector objects. So my idea was to omit the 


As consequence, I removed it and want to 

```{r new_RSS_function}
calc_RSS_dev <- function(lambda_vector, RSScurve = curve){

  # The linear part of HELA (see Bluszcz & Adamiec 2006) is performed by decompose_OSLcurve()
  RSScomponents <- decompose_OSLcurve_dev(RSScurve,
                                      lambda_vector,
                                      algorithm = "det",
                                      error.estimation = "only.bin.RSS",
                                      verbose = FALSE)

  # ... and calculate the residual sum of squares (RSS)
  RSS <- sum(RSScomponents$bin.RSS)
  if (is.na(RSS) || (RSS <= 0)) RSS <- Inf
  return(RSS)
}

```

First, we need to provide a sample curve as well as some lambda sets

```{r input_data}
# 'FB_10Gy' is a dose recovery test with the Fontainebleau quartz
# measured in a lexsyg research with green LED stimulation
data_path <- system.file("examples", "FB_10Gy_SAR.bin", package = "OSLdecomposition")
data_set <- Luminescence::read_BIN2R(data_path, fastForward = TRUE, verbose = FALSE)

# Plot all data points and give average CW-OSL curve back
test_curve <- sum_OSLcurves(data_set)

# Create some reasonable lambda vectors
lambda_vectors <- list(c(0.8),
                       c(0.8, 0.01),
                       c(10, 0.8, 0.01),
                       c(10, 0.8, 0.2, 0.003),
                       c(20, 5, 0.8, 0.2, 0.003))

```


Now let's do some basic benchmarks for the RSS calculation 

```{r bench_one}
RSS <- NA
for (K in 1:5) {
  cat("K = ", K, "\n")
  
  bench_old <- microbenchmark({RSS <- calc_RSS(lambda_vectors[[K]], test_curve)})
  cat("Old approach: RSS = ", RSS, "\n")
  cat(" Median computing time [ms] = ", median(bench_old$time) / 10^6, "\n")
  cat("\n")
  
  bench_new <- microbenchmark({RSS <- calc_RSS_dev(lambda_vectors[[K]], test_curve)})
  cat("New approach: RSS = ", RSS,"\n")
  cat(" Median computing time [ms] = ", median(bench_new$time) / 10^6, "\n")
  cat("\n")
}
```


The revised algorithm is about 4 times faster. Now let's test it in `fit_OSLcurve`:

```{r}
time.start <- Sys.time()
comp_new <- fit_OSLcurve_dev(test_curve, stimulation.wavelength = 535, K.max = 3, LM = FALSE)
cat("(time needed:", round(as.numeric(difftime(Sys.time(), time.start, units = "s")), digits = 2),"s)\n\n")
plot_OSLcurve(test_curve, comp_new)

time.start <- Sys.time()
comp_new <- fit_OSLcurve_dev(test_curve, stimulation.wavelength = 535, K.max = 3, LM = TRUE)
cat("(time needed:", round(as.numeric(difftime(Sys.time(), time.start, units = "s")), digits = 2),"s)\n\n")
plot_OSLcurve(test_curve, comp_new)

time.start <- Sys.time()
comp_old <- fit_OSLcurve(test_curve, stimulation.wavelength = 535, K.max = 3)
cat("(time needed:", round(as.numeric(difftime(Sys.time(), time.start, units = "s")), digits = 2),"s)\n\n")
plot_OSLcurve(test_curve, comp_old)


```



Test if the function still works as expected and try out all reasonable parameter combinations

```{r}

param_backg <- c(TRUE, FALSE)
param_algor <- c("det", "det+nls", "nls")
param_error <- c("poisson", "empiric", "only.bin.RSS", "nls", 13)


  # The linear part of HELA (see Bluszcz & Adamiec 2006) is performed by decompose_OSLcurve()
  RSScomponents <- decompose_OSLcurve_dev(RSScurve,
                                      lambda_vector,
                                      algorithm = "det",
                                      error.estimation = "only.bin.RSS",
                                      verbose = FALSE)
```

































