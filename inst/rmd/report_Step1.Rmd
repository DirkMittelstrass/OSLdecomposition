---
title: "Step 1: Multi-exponential CW-OSL fitting at global average curve"
output:
  html_document:
    theme: journal
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
    df_print: paged
params:
  fit_data: !r list(NULL)
  data_set: !r list(NULL)
---
This report was created at `r Sys.time()` with the **R** package **OSLdecomposition** `r packageVersion("OSLdecomposition")`

***

```{r step1_setup, include=FALSE}

# Last changed: 2020-04-19

library(numOSL)
library(knitr)
library(ggplot2)
library(gridExtra)
library(ggpubr)

knitr::opts_chunk$set(fig.width=7, #7
                      fig.asp=.6,
                      results = "asis",
                      warning=FALSE,
                      message=FALSE,
                      error=FALSE,
                      echo=FALSE,
                      cache=FALSE)

#fit_data <- params$fit_data

# numerate figures and tables
n.figure <- 1
n.table <- 1

# Find out the overall number of 'record_type' curves
# ToDo: Get this info (and the global_average data) directly from sum_OSLcurves outout
n.curves <- 0
for (j in 1:length(data_set)) {
  for (i in 1:length(data_set[[j]]@records)) {
   if (data_set[[j]]@records[[i]]@recordType == record_type) n.curves <- n.curves + 1
  }
}
```

## Summary
<font color="black">
The global average curve of `r n.curves` `r fit_data$parameters$record.type` records was calculated and then fitted with multi-exponential decay models with an increasing number of components *K* (Figure 2). A statistical test compared the models and found the *K* = `r fit_data$K.selected` model as sufficiently describing the global average curve (Table 1, Figure 1). 

```{r show_component_table}

cat(paste0("<br><i>Table ", n.table,": OSL component parameters of the K =", fit_data$K.selected," fitting</i><br>"))
n.table <- n.table + 1

component_table <- fit_data$components

component_table$lambda <- round(component_table$lambda, digits = 4)
component_table$initial.signal <- percent(component_table$initial.signal, accuracy = 0.1)
colnames(component_table) <- c(" ", "$\\lambda$ $(s^{-1})$", "n (counts)", "cross section (cm²)", "share at first channel", "fully bleached?")

kable(component_table, 
      escape = TRUE, align = "c",)

```


***

```{r step1_draw_best_suiting_fit}

plot_OSLcurve(fit_data$curve, 
              fit_data$components, 
              title = NULL)

cat(paste0("<br><font color=\"black\"><i>Figure ", n.figure,": Fit model with K =", fit_data$K.selected," (black), global average curve (grey) and signal components (colored)<br>", "<b>Upper left</b>: Linear diagram. <b>Upper right</b>: Double-logarithmic diagram<br>",
    "<b>Lower left</b>: Residual curve between fit and global average curve<br>",
    "<b>Lower right</b>: Fitting result table with estimated type of component names</i></font><br><br>"))
n.figure <- n.figure + 1
```

***

```{r step1_draw_crosssections_diagram, fig.width=10, fig.asp=0.32}

#cross.plot.height <- 0
#if ((stimulation_wavelength >= 465) && (stimulation_wavelength <= 480)) cross.plot.height <- 3
#cross.plot.height <- (cross.plot.height + 2 + K.selected) * 0.01
#knitr::opts_current$set(fig.asp = cross.plot.height)

plot_PhotoCrosssections(fit_data,
                        stimulation.intensity = fit_data$parameters$stimulation.intensity,
                        stimulation.wavelength = fit_data$parameters$stimulation.wavelength)

# <font color=\"black\"> </font>

  cat(paste0("<br><font color=\"black\"><i>Figure ", n.figure,": OSL signal component decay rates in dependence of component number *K*. </font><font color=\"red\">Red rectangle:</font><font color=\"black\"> Sufficient fitting choosen by the F-test.</i></font><br><br>"))
n.figure <- n.figure + 1
```

<br><br>

## Global OSL curve

For calculating the decay parameters, one representative OSL curve is needed. This is provided by combining all records to one global mean curve. Each data point of the global curve represents the arithmetic mean of all data point values of the same channel in all OSL curves. This increases the signal-to-noise ratio by about one to two orders of magnitude, but still maintains the decay parameter information.  

```{r draw_global_curve}

sum_OSLcurves(data_set,
              record_type = fit_data$parameters$record.type,
              output.plot = TRUE,
              plot.first = TRUE,
              plot.global = TRUE,
              title = NULL,
              verbose = FALSE,
              return.plot = TRUE)

cat(paste0("<br><font color=\"black\"><i>Figure ", n.figure,": Global average curve </i></font><br><br>"))
n.figure <- n.figure + 1
```


## Multi-exponential fitting {.tabset .tabset-pills}

We take the global mean curve and perform multiple cycles of multi-exponential nonlinear regression. In each cycle, the number of components *K* increases by one. With increasing number of components, decreases the signal deviation (residual curve) between the fitted model curve and the measured data and the fit gets better. 

The underlying algorithm was proposed and described by Bluszcz & Adamiec (2006) and realized in **R** by the function `numOSL::decomp()` by Peng *et al.* (2013). Their function is used in `fit_OSLcurve()`, which calculated the following series of fittings, displayed with `plot_OSLcurve()`:

```{r define_fitting_tabs}

# Define dynamic Rmarkdown code
markdown_code <- c(
    "### K = {{i}}\n",
    "```{r tab_{{i}}}\n",
    "plot_OSLcurve(fit_data$curve, 
                fit_data$case.tables[[{{i}}]], 
                title = NULL)\n",
    "```\n",
    "* Upper left: Global mean curve (grey), fit model curve (black) and component signals",
    "* Upper right: Same as log-log diagram",
    "* Lower left: Residual curve between fit and global mean curve",
    "* Lower right: Result table with estimated type of component names (colored)",
    "\n"
  )

tabs <- lapply(as.list(1:nrow(fit_data$F.test)),
                function(i) knitr::knit_expand(text = markdown_code))


# Now knit the dynamic code. This has to be in a seperate chunk
```

`r knitr::knit(text = unlist(tabs))`

## F-test

But which of these fittings gives back a sufficient model of the global mean curve, without over-fitting it? We solve this by comparing the residual square sum (*RSS*) of each fitting with the *RSS* value of the previous fitting. Bluszcz & Adamiec (2006) propose to use a *F*-test:  

$$F_K = \frac{(RSS_{K-1} - RSS_K)/2}{RSS_K(N - 2K)} $$

Here, *N* is the number data points (channels) of the global average curve and *K* is the number of OSL components in the fitting model. If the *F*-value *F~K~* falls below the preset threshold value of *F~threshold~* = `r fit_data$parameters$F.threshold`, the new fitting model with *K* components is apparently not significantly better than the *K* - 1 model and will be chosen as algorithm output.

```{r F-test_table}

F_table <- fit_data$F.test
row_index <- c(1:nrow(F_table))
F_table <- cbind(data.frame(K = row_index), F_table)

# Nicer table header
if (fit_data$parameters$background.fitting == TRUE) {

  colnames(F_table) <- c("  K  ", paste0("$\\lambda_", row_index,"$ $(s^{-1})$"),"background","RSS","$F_K$")
} else {

  colnames(F_table) <- c("  K  ", paste0("$\\lambda_", row_index,"$ $(s^{-1})$"), "RSS","$F_K$")
}

# Chi² in Rmarkdown: $\\chi^2$

# print F-test table
kable(F_table, 
      escape = TRUE, align = "c",
      caption = "*Table 1: Decay constants and fit quality parameters for multi-exponentional decay fitting with K components*  ")
```

The fitting with *K* = `r fit_data$K.selected` components is found to be the best suiting model to describe the given sample. Signal components with not-first-order kinetics, however, can lead to over-fitting. It is recommended to take the results of the *K* = `r fit_data$K.selected - 1` fitting model also into consideration.  


## Further information

### Disclaimer

This report was automatically generated by functions of the **R** package `OSLdecomposition` written and maintained by Dirk Mittelstraß (<dirk.mittelstrass@luminescence.de>). The calculation process deploys also functions of the R packages `numOSL` introduced by Jun Peng *et al.* (2013) and `Luminescence` introduced by Sebastian Kreutzer *et al.* (2012)

This report and the containing results can be used, shared and published by the data set maintainer at will. If the results are published, however, it is demanded to state the main **R** package `OSLdecomposition` including its version number (`r packageVersion("OSLdecomposition")`). It is also recommended to add this report to the supplement of your publication.   

A full description of the method and the algorithms involved, as well as some performance tests, can be found in the master thesis this script is based upon:

-------------------

*D. Mittelstraß, ‘Decomposition of weak optically stimulated luminescence signals and its application in retrospective dosimetry at quartz’, Master thesis, TU Dresden, Dresden, 2019.*

-------------------


### Script settings


**Algorithm parameters** | 
-----------------------|----------------
Maximum allowed components |*K~max~* =  `r fit_data$parameters$K.max`
Threshold *F*-value | *F~threshold~* = `r fit_data$parameters$F.threshold`

### Session info

```{r session_info}

print(sessionInfo(), locale = FALSE)
```

## References
