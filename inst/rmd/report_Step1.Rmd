---
title: "Step 1: Multi-exponential CW-OSL fitting at global average curve"
output:
  html_document:
    theme: journal
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
    df_print: paged
params:
  fit_data: !r list(NULL)
  data_set: !r list(NULL)
  object_name: !r c("")
---
Report of the Mittelstraß *et al.* (2020) Step 1 analysis of the data set **`r object_name`** performed with the function `RLum.OSL_global_fitting()` from the **R** package `OSLdecomposition`  `r packageVersion("OSLdecomposition")` exexuted at `r Sys.time()`.

***

```{r step1_setup, include=FALSE}

Last_changed <- "2020-05-05"

library(kableExtra)
library(numOSL)
library(knitr)
library(ggplot2)
library(gridExtra)
library(ggpubr)

knitr::opts_chunk$set(fig.width=7, #7
                      fig.asp=.6,
                      results = "asis",
                      warning=FALSE,
                      message=FALSE,
                      error=FALSE,
                      echo=FALSE,
                      cache=FALSE)

# Find out the overall number of 'record_type' curves
# ToDo: Get this info (and the global_average data) directly from sum_OSLcurves outout
n.curves <- 0
for (j in 1:length(data_set)) {
  for (i in 1:length(data_set[[j]]@records)) {
   if (data_set[[j]]@records[[i]]@recordType == record_type) n.curves <- n.curves + 1
  }
}
```

## Basics
<font color="black">


<i><u>Planned content:</u>

* sheme about the steps with Step 1 highlighted
* short describtion of basic approach and fundamental assumptions
* general formula

</i><br>


## Results

The global average curve of `r n.curves` `r fit_data$parameters$record.type` records was calculated and then fitted with multi-exponential decay models with an increasing number of components *K* (Figure 2). A statistical test compared the models and found the *K* = `r fit_data$K.selected` model as sufficiently describing the global average curve (Table 1, Figure 1). 

```{r show_component_table}

cat(paste0("<br><i><b>Table 1:</b> Signal component parameters of the K=", fit_data$K.selected," multi-exponential decay model chosen as best suting fitting by an F-test. </i><br>"))

component_table <- fit_data$components

component_table$lambda <- round(component_table$lambda, digits = 4)
component_table$initial.signal <- paste0(round(component_table$initial.signal * 100, digits = 1), "%")
component_table$bleaching.grade <- paste0(round(component_table$bleaching.grade * 100, digits = 1), "%")
colnames(component_table) <- c(" ", "$\\lambda$ $(s^{-1})$", "$n$ (counts)", "$\\sigma$ (cm²)", "first channel share", "bleaching grade")

#kable(component_table, escape = TRUE, align = "c",) %>%
#  kable_styling(bootstrap_options = c("striped", "condensed"))

kable_styling(kable(component_table, escape = TRUE, align = "c",), 
              bootstrap_options = c("striped", "condensed"))

```
<br>
***  
<br>

```{r step1_draw_best_suiting_fit}

plot_OSLcurve(fit_data$curve, 
              fit_data$components, 
              title = NULL)

cat(paste0("<br><i><b>Figure 1:</b> Fit model with K =", fit_data$K.selected," (black), global average curve (grey) and signal components (colored)<br>", "<u>Upper left</u>: Linear diagram. <u>Upper right</u>: Double-logarithmic diagram<br>",
    "<u>Lower left</u>: Residual curve between fit and global average curve<br>",
    "<u>Lower right</u>: Fitting result table with estimated type of component names</i><br><br>"))
```

***

```{r step1_draw_crosssections_diagram, fig.width=10, fig.asp=0.32}

#cross.plot.height <- 0
#if ((stimulation_wavelength >= 465) && (stimulation_wavelength <= 480)) cross.plot.height <- 3
#cross.plot.height <- (cross.plot.height + 2 + K.selected) * 0.01
#knitr::opts_current$set(fig.asp = cross.plot.height)

plot_PhotoCrosssections(fit_data,
                        stimulation.intensity = fit_data$parameters$stimulation.intensity,
                        stimulation.wavelength = fit_data$parameters$stimulation.wavelength)

# <font color=\"black\"> </font>

  cat("<br><i><b>Figure 2:</b> Signal component decay rates in dependence of component number *K*.<br><u>Red rectangle</u>: Fitting model choosen by the F-test.</i><br><br>")
```

<br><br>

## Methods

### Global average curve

For calculating the decay parameters, one representative OSL curve is needed. This is provided by combining all measurements to one global average curve. Each data point of this global curve represents the arithmetic mean of all data point values of the same channel in all OSL curves. This increases the signal-to-noise ratio by about one to two orders of magnitude, but still maintains the decay parameter information.  

```{r draw_global_curve, fig.width=7, fig.asp=0.5}

sum_OSLcurves(data_set,
              record_type = fit_data$parameters$record.type,
              output.plot = TRUE,
              plot.first = TRUE,
              plot.global = TRUE,
              title = NULL,
              verbose = FALSE,
              return.plot = TRUE)

cat(paste0("<br><i><b>Figure 3:</b> <u>Blue line</u>: Global average curve built from the arithmetic mean of all curves. <br><u>Grey points</u>: Data from all measurements. <u>Red</u>: First measurement of the data set.</i><br><br>"))
```


### Multi-exponential fitting {.tabset .tabset-pills}

We take the global mean curve and perform multiple cycles of multi-exponential nonlinear regression. In each cycle, the number of components *K* increases by one. With increasing number of components, decreases the residual curve between the fitted model curve and the measured data and the fit gets better. 

The underlying algorithm was proposed and described by Bluszcz & Adamiec (2006) and realized in **R** by the function `numOSL::decomp()` by Peng *et al.* (2013). Their function is used in `fit_OSLcurve()`, which calculated the following series of fittings:

```{r define_fitting_tabs}

# Define dynamic Rmarkdown code
dynamic_code <- c(
    "#### K = {{i}}\n",
    "```{r tab_{{i}}}\n",
    "plot_OSLcurve(fit_data$curve, 
                fit_data$case.tables[[{{i}}]], 
                title = NULL)\n",
    "cat(paste0(\"<br><i><b>Figure 4.{{i}}:</b> Fit model with K = {{i}} (black), global average curve (grey) and signal components (colored)<br>\", \"<u>Upper left</u>: Linear diagram. <u>Upper right</u>: Double-logarithmic diagram<br>\",\"<u>Lower left</u>: Residual curve between fit and global average curve<br>\",\"<u>Lower right</u>: Fitting result table with estimated type of component names</i><br><br>\"))",
    "```\n"
  )

tabs <- lapply(as.list(1:nrow(fit_data$F.test)),
                function(i) knitr::knit_expand(text = dynamic_code))


# Now knit the dynamic code. This has to be in a seperate chunk
```

`r knitr::knit(text = unlist(tabs))`

### F-test

But which of these fittings gives back a sufficient model of the global mean curve, without over-fitting it? We solve this by comparing the residual square sum (*RSS*) of each fitting with the *RSS* value of the previous fitting. Bluszcz & Adamiec (2006) propose to use a *F*-test:  

$$F_K = \frac{(RSS_{K-1} - RSS_K)/2}{RSS_K(N - 2K)} $$

Here, *N* is the number data points (channels) of the global average curve and *K* is the number of OSL components in the fitting model. If the *F*-value *F~K~* falls below the preset threshold value of *F~threshold~* = `r fit_data$parameters$F.threshold`, the new fitting model with *K* components is apparently not significantly better than the *K* - 1 model and will be chosen as algorithm output.

```{r F-test_table}

F_table <- fit_data$F.test
row_index <- c(1:nrow(F_table))
F_table <- cbind(data.frame(K = row_index), F_table)

# Make a nicer table header
if (fit_data$parameters$background.fitting == TRUE) {

  colnames(F_table) <- c("  $K$  ", paste0("$\\lambda_", row_index,"$ $(s^{-1})$"), "background", "RSS", "$F_K$")
} else {

  colnames(F_table) <- c("  $K$  ", paste0("$\\lambda_", row_index,"$ $(s^{-1})$"), "RSS","$F_K$")
}

cat(paste0("<br><i><b>Table 2:</b> Decay constants and fitting quality parameters in dependence of component number $K$. <br><u>RSS</u>: Residual square sum. <u>$F_K$</u>:  Measure of fitting improvement.</i><br>"))

# print F-test table
kable_styling(kable(F_table, escape = TRUE, align = "c",), 
              bootstrap_options = c("striped", "condensed"))
```

The fitting with *K* = `r fit_data$K.selected` components is found to be the best suiting model to describe the given sample. Signal components with not-first-order kinetics, however, can lead to over-fitting. In case of more than 3 components, it is recommended to take the results of the *K* = `r fit_data$K.selected - 1` fitting model also into consideration.   



## Disclaimer

This report was automatically generated by functions of the **R** package `OSLdecomposition` written and maintained by Dirk Mittelstraß (<dirk.mittelstrass@luminescence.de>). The data analysis process deploys also functions and concepts of the **R** packages `numOSL` ([link](https://cran.r-project.org/package=numOSL)) introduced by Jun Peng *et al.* (2013) and `Luminescence` ([link](https://cran.r-project.org/package=Luminescence)) introduced by Sebastian Kreutzer *et al.* (2012). For the dynamic creation of this HTML report, the **R** packages `knitr` and `rmarkdown` are used, see Xie (2015) and Xie *et al.* (2018). All diagrams are drawn with `ggplot2` (Wickham 2016).

You can use, share and publish this report and the containing results at will, as long as you have the consent of the measurement data maintainer. If this report or its results are published, however, it is requested to refer to the main **R** package `OSLdecomposition` including its version number (`r packageVersion("OSLdecomposition")`). It is also demanded to include the following reference into your publication:

-------------------

*D. Mittelstraß, ‘Decomposition of weak optically stimulated luminescence signals and its application in retrospective dosimetry at quartz’, Master thesis, TU Dresden, Dresden, 2019.*

-------------------

There, you can find a full description of the method and the algorithms involved, as well as some simulation-based performance tests. 

It is allowed and encouraged to add the HTML file of this report to the electronical supplement of your publication.  


## References

Bluszcz, A., Adamiec, G., 2006. Application of differential evolution to fitting OSL decay curves. Radiation Measurements 41, 886–891. 
https://doi.org/10.1016/j.radmeas.2006.05.016

Kreutzer, S., Schmidt, C., Fuchs, M.C., Dietze, M., Fuchs, M., 2012. Introducing an R package for luminescence dating analysis. Ancient TL 30.

Peng, J., Dong, Z., Han, F., Long, H., Liu, X., 2013. R package numOSL: numeric routines for optically stimulated luminescence dating. Ancient TL 31.

Wickham, H., 2016. ggplot2: elegant graphics for data analysis, Second edition. ed, Use R! Springer, Cham.
https://ggplot2.tidyverse.org/

Xie, Y., 2015. Dynamic documents with R and Knitr, Second edition. ed. CRC Press/Taylor & Francis, Boca Raton.
https://yihui.org/knitr/

Xie, Y., Allaire, J.J., Grolemund, G., 2018. R Markdown: the definitive guide. Taylor & Francis, CRC Press, Boca Raton.
https://bookdown.org/yihui/rmarkdown/


## Script parameters

Last major change in the script code: `r Last_changed`  

**Algorithm parameters** | 
-----------------------|----------------
Maximum allowed components |*K~max~* =  `r fit_data$parameters$K.max`
Threshold *F*-value | *F~threshold~* = `r fit_data$parameters$F.threshold`

</font>
**Session info:**

```{r session_info}
print(sessionInfo(), locale = FALSE)
```

